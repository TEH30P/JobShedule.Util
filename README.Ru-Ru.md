# JobShedule.Util
Модуль предоставляет функции и командлеты, которые помогают делать скрипты для выполнения по расписанию.
В кратце это:
* логирование - команды `~SJLog~*`. Логи пишутся в формате [YAML](http://yaml.org/). Для работы лога нужно указать папку, куда логировать; она указывается в первом параметра загрузки модуля или через вызов команды "`~SJLog~Dir~Set <путь-к-папке> -fRoot`".
  * `~SJLog~Msg~New` - обычное сообщение в лог
  * `~SJLog~MsgException~New` - сообщение которое должен генерировать catch блок, параметром передаётся объект ErrorRecord, т.е. переменная `$_` в catch блоке.
* чтение и разбор (парсинг) конфигураций - команда `~SJob~FileConf~Load`
  * `~FileConf~Load` - загружает и разбирает (распарсивает) файл конфигурации, возвращает PSObject с деревом значений.
* именоване файлов - команды `~FSName~*`. При этом "." (точка) запрещённый символ - она экранируется.
  * Глаголы:
    * `*~Convert` - конвертирует переданное значение в строку которую можно использовать как имя файла или его часть; 
	* `*~NConvert` - то же что `*~Convert`, но допускает `$null` на входе (для него спец-код); 
	* `*~Parse` - распарсивает фрагмент имени файла сделаный `*~Convert`;
	* `*~NParse` - то же что `*~Parse` но допускает наличие кода для `$null` значения, т.е. распарсивает фрагмент сделаный `*~NConvert`.
  * Команды:
    * `~FSName~Bin~*` - конвертирование бинарных строк `[byte[]]`.
    * `~FSName~UInt~*` - конвертирование целых чисел `[byte]` ... `[bigint]`.
    * `~FSName~Str~*` - конвертирование строк `[string]` (escape-замена).
    * `~FSName~DT~*` - конвертирование даты.времени `[datetime]`.
* хранение и вычисление временных интервалов (частот) - команды `~TimeFreq~*` *[пока не реализовано]*.

## Формат файла конфигурации.
В данный момент поддерживаеются `xml` и `json` форматы (в планах поддержка `.psd1`). Имя корневого элемента передаётся команде загрузки файла.
Имена "узлов" (в том числе и корневого) конфигурациооного файла должны иметь следующий формат:
* узлы с префиксом `SV-` - простое, одиночное значение.
* узлы с префиксом `LV-` - список значений.
* узлы с префиксом `OV-` - ассоциотивный список (структура/словарь) из значений.
* узлы с префиксом `OL-` - список из ассоциотивных списков (структур/словарей) из значений.
* узел с именем `V-Is` - "собственное значение" родительского узла. Допустим только для узлов `SV-*` и `LV-*`, не может быть у корневого узла.

>Узел `V-Is` не обязателен, если языковой формат допускает "собственное значение" узла.
~~~ xml
<OV-MyConf>
  <SV-Inherits V-Is="dummy\conf.xml" />
</OV-MyConf>
~~~
~~~ xml
<OV-MyConf>
  <SV-Inherits>dummy\conf.xml</SV-Inherits>
</OV-MyConf>
~~~
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": { "V-Is": "dummy\\conf.xml" }}
}
~~~
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": "dummy\\conf.xml" }
}
~~~

>Простое значение может иметь подъузлы (потомков), но наличие "собственного значения" обязательно.
~~~ xml
<OV-MyConf>
  <SV-Inherits V-Is="dummy\conf.xml" SV-Required="YES"/>
</OV-MyConf>
~~~
~~~ xml
<OV-MyConf>
  <SV-Inherits SV-Required="YES" >dummy\conf.xml</SV-Inherits>
<OV-MyConf>
~~~
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": { "V-Is": "dummy\\conf.xml", "SV-Required": "YES"}}
}
~~~

>Список значений может быть представлен в формате простого значения, тогда он трактуется как список из одного элемента.
~~~ xml
<OV-MyConf>
  <LV-Server V-Is="FOO" />
  <LV-Server V-Is="BAR" />  
</OV-MyConf>
~~~
~~~ xml
<OV-MyConf>
  <LV-Server V-Is="ONLY" />
</OV-MyConf>
~~~
~~~ json
{  "OV-MyConf": 
  {  "LV-Server": ["FOO", "BAR"]}
}
~~~
~~~ json
{  "OV-MyConf": 
  {  "LV-Server": "ONLY"}
}
~~~

> Языковой формат не важен, главное связь потомок-родитель - т.е. путь к узлу.
~~~ xml
<OV-MyConf>
  <SV-Inherits V-Is="dummy\conf.xml" SV-Required="YES"/>
</OV-MyConf>
~~~
~~~ xml
<OV-MyConf>
  <SV-Inherits>
    <V-Is>dummy\conf.xml</V-Is>
    <SV-Required>YES</SV-Required>
  </SV-Inherits>
<OV-MyConf>
~~~
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": { "V-Is": "dummy\\conf.xml", "SV-Required": "YES"}}
}
~~~

---
Пока пройден первый этап разработки - **ЗАСТАВЬ ЭТО РАБОТАТЬ**; этап **ЗАСТАВЬ ЭТО РАБОТАТЬ БЫСТРО**, надеюсь, близок к завершению; а развитие процесса **ЗАДОКУМЕНТИРУЙ ЭТО** остановилось на этом документе.
