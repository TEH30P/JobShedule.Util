---
language: powershell
module: JobShedule.Util
module file: JobShedule.Util.psm1
---
# Модуль `JobShedule.Util`
Модуль предоставляет функции и командлеты, которые помогают делать скрипты для выполнения по расписанию.

Параметры: 
- \#0 - : **`!обяз`**, `[string]` - путь к корневой папке, куда надо складывать логи. Если праметр не указан, то командлеты записи в лог не будут работать.

# Команды логирования 
`*-SJLog*` (`~SJLog~*`)

Логи пишутся в формате [YAML](http://yaml.org/). Для работы лога нужно указать папку, куда логировать; она указывается в первом параметра загрузки модуля или через вызов команды "`~SJLog~Dir~Set <путь-к-папке> -fRoot`". Алгоритм формирования сообщений и записи их в файлы оптимизирован на минимальное использование дополнительных буфферов памяти: чтоб увеличить вероятность успешной записи в лог, в ситуациях когда хост испытывает критические нагрузки (например недостаток памяти). Так же алгоритм формирования сообщения в лог реализован так, что в случае сбоя записи сообщения, целостность логической структуры файла лога в целом не будет нарушена.

Имя файла лога формируется следующим образом:
~~~ EBNF
log-name = log-date , "." , log-source , "." , log-severity , "." , process-identity , ".yml" ;
log-date         = ? Значение параметра `iLogAt` команд записи в лог, закодированная в текст по алгоритму аналогичному `ConvertTo-FSNameDT` ? ;
log-source       = ? Значение параметра `iLogSrc` команд записи в лог, закодированная в текст по алгоритму аналогичному `ConvertTo-FSNameStr` ? ;
log-severity     = ? Значение параметра `iLogSeverity` (трёх-буквенный код) команд записи в лог ? ;
process-identity = ? Бинарная строка `$Host.InstanceId` закодированная в текст по алгоритму аналогичному `ConvertTo-FSNameBin`? ;
~~~

## Команда `New-SJLogMsg` (`~SJLog~Msg~New`)
Обычное сообщение в лог.

Параметры: 
- \#0 `iLogSeverity` : **`!обяз`**, `[NPSShJob.EMsgSevernity]` - Уровень "важности" сообщения, указываемый в имени файла лога:
   - "`Inf`", "`I`" - (значение по-умолчанию) информационное сообщение.
   - "`Err`", "`E`" - блокирующая ошибка, обычно после этого сообщения выполнение скрипта должно остановиться.
   - "`Wrn`", "`W`" - НЕ-блокирующая ошибка.
   - "`Dbg`", "`D`" - отладочное сообщение, в продуктивной версии, по-хорошему, подобных сообщений не должно быть.
- \#1 `iLogAt` : **`обяз`**, `[datetime]` - Дата которая указывается в имени файла лога.
- \#2 `iaMsg` : **`обяз`**, `[string[]]` - Одно или несколько сообщений в лог.
-  `iAt` : **`!обяз`**, `[datetime]` - Дата сообщения в лог. По-умолчанию "текущая дата".
-  `iKey` : **`!обяз`**, `[string]` - Если параметр передан, то вместо даты, в сообщении будет указано переданное слово.
-  `iLogSrc` : **`!обяз`**, `[string]` - Источник лога. Будет указан в имени файла лога.
-  `fAsKeyValue` : **`!обяз`**, `[switch]` - Трактовать список сообщений `iaMsg` как "ключь - значение" и будет записан в формате [YAML-Mapping](https://yaml.org/spec/1.2/spec.html#mapping//). Каждый чётный элемент будет считаться "ключём", а нечётный "значением". Если флаг не указан, то элементы `iaMsg` будут записан в лог как [YAML-Sequence](https://yaml.org/spec/1.2/spec.html#sequence//).

## Команда `New-SJLogExceptionMsg` (`~SJLog~MsgException~New`)
Сообщение в лог, которое должен генерировать catch блок.

Параметры:
- \#0 `iLogSeverity` : **`!обяз`**, `[NPSShJob.EMsgSevernity]` - Уровень "важности" сообщения, указываемый в имени файла лога. Аналогично таком же параметру `New-SJLogMsg`. По-умолчанию "`Err`".
- \#1 `iLogAt` : **`обяз`**, `[datetime]` - Дата которая указывается в имени файла лога.
- \#2 `iPSErrorInfo` : **`обяз`**, `[psobject]` - Объект ErrorRecord, т.е. переменная `$_` в catch блоке.
-  `iAt` : **`!обяз`**, `[datetime]` - Дата сообщения в лог. По-умолчанию "текущая дата".
-  `iLogSrc` : **`!обяз`**, `[string]` - Источник лога. Будет указан в имени файла лога.

## Команда `New-SJLogCloseMsg` (`~SJLog~MsgClose~New`)
Добавить в лог строку разделитель [YAML-Directivs-end](https://yaml.org/spec/1.2/spec.html#marker/directives%20end/).

Некоторые системы мониторинга/сбора логов, требуют наличия символа перевода строки, как индикатор "завершенности" последнего сообщения лога. Выполнив эту команду, можно сделать предыдущее сообщение лога "видимым".

Параметры:
- \#0 `iLogSeverity` : **`обяз`**, `[NPSShJob.EMsgSevernity]` - Уровень "важности" сообщения, указываемый в имени файла лога. Аналогично таком же параметру `New-SJLogMsg`.
- \#1 `iLogAt` : **`обяз`**, `[datetime]` - Дата которая указывается в имени файла лога.
-  `iLogSrc` : **`!обяз`**, `[string]` - Источник лога. Будет указан в имени файла лога.

## Команда `Set-SJLogDir` (`~SJLog~Dir~Set`)
Изменение настроек логирования: путь для хранения файлов логов.

Параметры:
- \#0 `iPath` : **`обяз`**, `[string]` - Путь к папке хранения логов.
-  `fRoot` : **`обяз`**, `[switch]` - Если указан, то в `iPath` устанавливается путь к корневой папке хранения логов; иначе к подпапке внутри корневой.

# Команды разбора файла конфигурации 
`*-SJConf-*` (`~SJConf~*`)

Файл конфигурации представляет собой древо значений построенное по принцыпу ключь-значение. Для физического представления, наряду с `Powershell data section (.psd1)`, используются различные декларативные языки. Так же поддерживается наследование и инкапсулируется процесс разбора значений всех основных типов данных. Подробнее см. "Формат файла конфигурации".

## Команда `Import-SJConfFile` (`~SJConf~File~Parse`)
Загружает и разбирает (распарсивает) файл конфигурации.

Команда загружает и распарсивает структуру (НЕ-значения) файла конфигурации, а так же всех базовых файлов конфигурации, если таковые указаны в параметрах. Базовый файл конфигурации указывается в параметрах `iKeyBasePath`, `iBasePath`. После того как файл указаный в `iPath` распарсен, если передан параметр `iKeyBasePath`, функция ищет в потомках корневого узла, узел с именем `iKeyBasePath`. Если `iKeyBasePath` найден то загружается и распарсивается файл по этому пути. Если `iKeyBasePath` не указан или не найден, то загружается файл по пути `iBasePath`; а если `iBasePath` не указан, то работа команды завершается. Если полученный из `iKeyBasePath`  путь относительный, то в качестве базового пути используется путь к текущему фалу конфигурации. Например `$iPath = 'c:\myscript0\my.conf.psd1'` в котором указан путь к базовой конфигурации "`..\default.conf.psd1`". После загрузки "`c:\myscript0\my.conf.psd1`" будет загружен, файл "`c:\default.conf.psd1`" = "`c:\myscript0`" + "`..\default.conf.psd1`" .

Результат:
* `[NPSShJob.CConfData]` : распарсенная структура конфига, если у файла есть базовые конфигурации, то будет возвращено по одной структуре для каждого файла в цепочке наследования. `[NPSShJob.CConfData]` имеет следующие атрибуты: 
  * `FilePath` : `[string]` - путь к конфигурационному файлу.
  * `ValueTree` : `[Collections.IDictionary]` - Дерево значений конфигурации - словарь из словарей.
- *`!ошибка!`* : файл конфигурации не найлен в цепочке конфигураций.
- *`!ошибка!`* : один из файлов в цепочке конфигураций не найден.

Параметры: 
- \#0 `iPath` : **`обяз`**, `[string]` - Путь к файлу конфигурации.
- \#1 `iKeyRoot` : **`!обяз`**, `[string]` - Имя корневого узла в файле конфигурации, из котрого надо строить дерево значений.
-  `iKeyBasePath` : **`!обяз`**, `[string]` - Имя узла, потомка корня дерева значений, в котором указан путь к файлу базовой конфигурации. Путь может быть абсолютным или относительным. Для относительного пути, в качестве "корневой" папки будет использоваться путь к текущему файлу конфигурации.
-  `iBasePath` : **`!обяз`**, `[string]` - Абсолютный путь к файлу default-значений конфигурации. Если `iKeyBasePath` не указан или в файле он не найден, то в качестве пути к базовой конфигурации будет использоваться это значение.
-  `iTimeOut` : **`!обяз`**, `[timespan]` - Время на процесс повторных попыток загрузки файла конфигурации, если он занят другим процессом. По-умолчанию 30 сек.

## Команда `Update-SJConfScalar` (`~SJConf~Scalar~Parse`)
Разбор одиночного значения из узла, соданного `Import-SJConfFile` дерева значений.

Команда обновляет значение в узле дерева конфигурации в соответствии с требуемым типом `iType`. Команда проверяет к какому типу относится исходное значение, если оно типа `[string]` и `iType` не `[string]`, то будет выполнен разбор строкового предстваления в соответствии с форматом требуемого типа. Если исходный тип отличен от `[string]` и отличен от `iType`, то выполняется простое преобразование типа. В остальных случаях значение в узле дерева конфига не меняется. Подробнее см. "Формат файла конфигурации."

Результат:
- *`!ошибка!`* : Значение отсутствует в дереве значений и НЕ взведён флаг `fNullable`.
- *`!ошибка!`* : Значение имеет неверный строковый формат.
- *`!ошибка!`* : Ошибка преобразования типа значения к типу `iType`.
* `[*]` : (тип указаный в параметре `iType`) : если взведён флаг `fOut`, то найденное преобразованное значение конфигурации.

Параметры: 
- \#0 `ioConf` : **`обяз`**, `[Collections.IDictionary]` - Узел дерева значений, родитель искомого значения конфигурации. Корневой узел это `[NPSShJob.CConfData]::ValueTree`.
- \#1 `iName` : **`обяз`**, `[string]` - Имя значения конфигурации.
- \#3 `iType` : **`обяз`**, `[type]` - Требуемый тип (имя типа) значения конфигурации.
-  `fNullable` : **`!обяз`**, `[switch]` - Значение не обязательное, если оно не найдено вместо ошибки, команда просто ничего не вернёт.
-  `fOut` : **`!обяз`**, `[switch]` - Команда должна вернуть найденное значение. Иначе: команда ничего не вернёт никогда.

## Команда `Update-SJConfList` (`~SJConf~List~Parse`)
Разбор списка значений из узла, соданного `Import-SJConfFile` дерева значений.

Команда обновляет значение в каждом элементе списка в узле дереве конфигурации в соответствии с требуемым типом `iType`. Команда проверяет к какому типу относится исходное значение элемента списка, если оно типа `[string]` и `iType` не `[string]`, то будет выполнен разбор строкового предстваления в соответствии с форматом требуемого типа. Если исходный тип отличен от `[string]` и отличен от `iType`, то выполняется простое преобразование типа. В остальных случаях значение элемента списка в узле дерева конфига не меняется. Подробнее см. "Формат файла конфигурации."

Результат:
- *`!ошибка!`* : Значение отсутствует в дереве значений и НЕ взведён флаг `fNullable`.
- *`!ошибка!`* : Значение имеет неверный строковый формат.
- *`!ошибка!`* : Ошибка преобразования типа значения к типу `iType`.
* `[*]` : (тип указаный в параметре `iType`) : если взведён флаг `fOut`, то найденное преобразованное значение конфигурации.

Параметры: 
- \#0 `ioConf` : **`обяз`**, `[Collections.IDictionary]` - Узел дерева значений, родитель искомого значения конфигурации. Корневой узел это `[NPSShJob.CConfData]::ValueTree`.
- \#1 `iName` : **`обяз`**, `[string]` - Имя значения конфигурации.
- \#3 `iType` : **`обяз`**, `[type]` - Требуемый тип (имя типа) элементов списка значений конфигурации.
-  `fNullable` : **`!обяз`**, `[switch]` - Значение не обязательное, если оно не найдено вместо ошибки, команда просто ничего не вернёт.
-  `fOut` : **`!обяз`**, `[switch]` - Команда должна вернуть найденное значение. Иначе: команда ничего не вернёт никогда.

## Команда `Merge-SJConfScalar` (`~SJConf~Scalar~Inherit`)
Процедура наследования единичного (скалярного) значения.

Команда сравнивает значения базового `iObj` и целевого `ioObjParent` узла дерева конфигурации. Если значение отсутствует в целевом дереве, но есть в базовом; то оно добавляется в целевое дерево.

Параметры:
- \#0 `ioObjParent` : **`обяз`**, `[Collections.IDictionary]` - Узел целевого дерева значений, родитель искомого значения конфигурации. Корневой узел это `[NPSShJob.CConfData]::ValueTree`.
- \#1 `iObj` : **`обяз`**, `[Collections.IDictionary]` - Узел базового дерева значений, родитель искомого значения конфигурации. Корневой узел это `[NPSShJob.CConfData]::ValueTree`.
- \#2 `iPropN` : **`обяз`**, `[string]` - Имя значения конфигурации.

## Команда `Merge-SJConfList` (`~SJConf~List~Inherit`)
Процедура наследования списка значений.

Команда объединяет списки значений базового `iObj` и целевого `ioObjParent` узла дерева конфигурации. Элементы списка базового узла (если таковой имеет значение), добавляются в конец списка целевого узла. Если целевой узел не имеет значения, то значение базового узла, копируется в целевой.

Параметры:
- \#0 `ioObjParent` : **`обяз`**, `[Collections.IDictionary]` - Узел целевого дерева значений, родитель искомого значения конфигурации. Корневой узел это `[NPSShJob.CConfData]::ValueTree`.
- \#1 `iObj` : **`обяз`**, `[Collections.IDictionary]` - Узел базового дерева значений, родитель искомого значения конфигурации. Корневой узел это `[NPSShJob.CConfData]::ValueTree`.
- \#2 `iPropN` : **`обяз`**, `[string]` - Имя значения конфигурации.

# Команды преобразования значения в строку допустимую в имени файла 
`Convert*-FSName*` (`~FSName~*~?Convert`, `~FSName~*~?Parse`)

Команды преобразуют значения в строку, которую можно использовать в качестве имени файла/папки или его части, а так же выполняют обратное преобразование из строки в значение определённого типа. Запрещённые в именах файлов символы и символ точки "`.`" экранируются по алгоритму [Percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding).

## Команда `ConvertTo-FSNameBinN` (`~FSName~Bin~NConvert`)
Конвертирует бинарную строк `[byte[]]`, `$null` допустимо и преобразуется в пустую строку.

Входная бинарная строка конвертируется в длинное base-32 (тридцатидвух-ичное) число.
~~~ 
исчисление-10 1-разряд (десятки): 00000000001111111111222222222233
исчисление-10 0-разряд (единицы): 01234567890123456789012345678901
исчисление-32:                    0123456789ABCDEFGHJKMNPRSTUVWXYZ
~~~

Результат:
- `[string]` : Строка, которую можно использовать в качестве имени файла.

Параметры:
- \#0 `iValue` : **`обяз`**, `[byte[]]` - Исходное значение - бинарная строка.
- \#1 `iLen` : **`!обяз`**, `[int32]` - Минимальная длина выходной строки. Выходная строка будет дополнена "`0`" слева, если её длина будет мала.  По-умолчанию `0`.

## Команда `ConvertTo-FSNameBin` (`~FSName~Bin~Convert`)
Аналогична `ConvertTo-FSNameBinN`, но `$null` не допускается.

## Команда `ConvertTo-FSNameUIntN` (`~FSName~UInt~NConvert`)
Конвертирует целое число `[byte]` ... `[bigint]`, `$null` допустимо.

Результат:
- `[string]` : Строка, которую можно использовать в качестве имени файла.

Параметры:
- \#0 `iValue` : **`обяз`**, `[bigint]` - Исходное значение - целое число.
- \#1 `iPrec` : **`обяз`**, `[int32]` - Общее число знаков (длина результирующей строки). Результат заполняется до требуемой длины нулями "`0`" слева.

## Команда `ConvertTo-FSNameUInt` (`~FSName~UInt~Convert`)
Аналогична `ConvertTo-FSNameUIntN`, но `$null` не допускается.

## Команда `ConvertTo-FSNameStr` (`~FSName~Str~Convert`)
Конвертирует строку `[string]` (escape-замена). `$null` допускается и преобразуется в пустую строку.

Экранируются запрещённые в именах файлов символы и символ точки: "`.?*\/:|><%`".

Результат:
- `[string]` : Строка, которую можно использовать в качестве имени файла.

Параметры:
- \#0 `iValue` : **`обяз`**, `[string]` - Исходная строка.

## Команда `ConvertTo-FSNameDTN` (`~FSName~DT~NConvert`)
Конвертирует дату-время `[datetime]`, `$null` допускается.

Дата преобразуется в строку с в [формате С\#](https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings) : "`yyyyMMdd-HHmmss-ffffff`", точность настраивается параметрами `iScale` и `iPrec`.

`iScale` - строка кодирующая точность даты до секунды, значение должно соответсвовать шаблону: "`^(d|d[ymd])?(t|t[hms])?$`". Грамматика:
~~~ EBNF
dt-scale   = time-scale | date-scale [, time-scale] ;
time-scale = "t" , [ "h" | "m" | "s" ] ;
date-scale = "d" , [ "y" | "m" | "d" ] ;
~~~
- "`dy`" : дата с точностью до "года", выходной C# формат "`yyyy`"; `$null` -- "`____`";
- "`dm`" : дата с точностью до "месяца", выходной C# формат "`yyyyMM`"; `$null` -- "`_______`";
- "`dd`", "`d`" : дата с точностью до "дня", выходной C# формат "`yyyyMMdd`"; `$null` -- "`________`";
- "`th`" : время с точностью до "часа", выходной C# формат "`HH`"; `$null` -- "`__`";
- "`tm`" : время с точностью до "минуты", выходной C# формат "`HHmm`"; `$null` -- "`____`";
- "`ts`", "`t`" : время с точностью до "секунды", выходной C# формат "`HHmmss`"; `$null` -- "`_______`";
- "`ddts`", "`dt`" : полный формат дата-время "`yyyyMMdd-HHmmss`"; `$null` -- "`________-______`";
- "`d*t*`" : частичный формат дата-время; например "`dmth`" - дата до месяца и время до часа, выходной C# формат "`yyyyMM-HH`".

Параметр `iPrec` определяет точность долей секунды. Фактически это количество символов "`f`" в C\# формате даты. Например для `$iScale = "t"; $iPrec = 3` C\# формат будет "`HHmmss-fff`".

Результат:
- `[string]` : Строка, которую можно использовать в качестве имени файла.

Параметры:
- \#0 `iValue` : **`обяз`**, `[datetime]` - Исходное значение - дата-время.
- \#1 `iScale` : **`обяз`**, `[string]` - настройки точности даты-времени до секунды, подробное описание формата см. выше.
- \#2 `iPrec` : **`обяз`**, `[int32]` - настройки точности долей секунд, подробное описание формата см. выше.

## Команда `ConvertTo-FSNameDT` (`~FSName~DT~Convert`)
Аналогична `ConvertTo-FSNameDTN`, но `$null` не допускается.

## Команда `ConvertFrom-FSNameBinN` (`~FSName~Bin~NParse`)
Разбирает строку представления бинарного формата. Формат допускает код для `$null`.

Подробнее см. `ConvertTo-FSNameBinN`.

Результат:
- `[byte[]]` : Бинарная строка, которая была закодирована в `iValue`.

Параметры:
- \#0 `iValue` : **`обяз`**, `[string]` - Исходная строка.

## Команда `ConvertFrom-FSNameBin` (`~FSName~Bin~Parse`)
Аналогична `ConvertFrom-FSNameBinN`, но `$null` не допускается.

## Команда `ConvertFrom-FSNameUIntN` (`~FSName~UInt~NParse`)
Разбирает строку представления целого числа. Формат допускает код для `$null`.

Подробнее см. `ConvertTo-FSNameUInt`.

Результат:
- `[bigint]` : Число, которое было закодировано в `iValue`.

Параметры:
- \#0 `iValue` : **`обяз`**, `[string]` - Исходная строка.

## Команда `ConvertFrom-FSNameUInt` (`~FSName~UInt~Parse`)
Аналогична `ConvertFrom-FSNameUIntN`, но `$null` не допускается.

## Команда `ConvertFrom-FSNameStrN` (`~FSName~Str~NParse`)
Разбирает строку, в которой была сделана escape-замена.

Подробнее см. `ConvertFrom-FSNameStr`.

Результат:
- `[string]` : Строка в которой сделаа обратная escape-замена.

Параметры:
- \#0 `iValue` : **`обяз`**, `[string]` - Исходная строка.

## Команда `ConvertFrom-FSNameDTN` (`~FSName~DT~NParse`)
Разбирает строку представления даты-времени. Формат допускает код для `$null`.

Подробнее см. `ConvertTo-FSNameDTN`.

Результат:
- `[datetime]` : Дата-время, которое было закодировано в `iValue`.

Параметры:
- \#0 `iValue` : **`обяз`**, `[string]` - Исходная строка.

## Команда `ConvertFrom-FSNameDT` (`~FSName~DT~Parse`)
Аналогична `ConvertFrom-FSNameDTN`, но `$null` не допускается.

# Формат файла конфигурации.
В данный момент поддерживаеются `xml`, `json` и `.psd1` форматы.

Имена "узлов" (в том числе и корневого) конфигурациооного файла должны иметь следующий формат:
* узлы с префиксом "`SV-`" - простое, одиночное значение.
* узлы с префиксом "`LV-`" - список значений.
* узлы с префиксом "`OV-`" - ассоциативный список (структура/словарь) из значений.
* узлы с префиксом "`OL-`" - список из ассоциативных списков (структур/словарей) из значений.
* узел с именем "`V-Is`" - "собственное значение" родительского узла, используется, когда языковой формат файла не допускает наличие "собственного значения". Допустим только для узлов `SV-*` и `LV-*`, не может быть у корневого узла.

Поддерживаются следующие типы значений:
* число: [`SByte`], [`Byte`], [`Int16`], [`UInt16`], [`Int32`], [`UInt32`], [`Int64`], [`UInt64`], [`Single`], [`Double`], [`Decimal`] - если язык файла не поддерживает тип данных непосредственно, то следует использовать строковое представление в формате [XSD Datatypes](https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes) c суффиксом числа в powershell "`kb`", "`mb`" и т.д.
* дата и время : [`TimeSpan`], [`DateTime`] - если язык файла не поддерживает тип данных непосредственно, то следует использовать строковое представление в формате [XSD Datatypes](https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes).
* строки : [`String`], [`Char`] - в стандартном для выбранного языка файла представлении.
* списки/массивы - если язык файла не поддерживает их непосредственно, то способ их задания оговаривается отдельно.

Узел `V-Is` не обязателен, если языковой формат файла допускает "собственное значение" узла.

Пример, значение: `$SVInherits = 'dummy\conf.xml'`, может быть сохранено как:
* собственное значение узла в Powershell Data или с использованем `V-Is`
~~~ powershell
@{'OV-MyConf' = 
  @{'SV-Inherits' = 'dummy\conf.xml'}
}
~~~
~~~ powershell
@{'OV-MyConf' = 
  @{'SV-Inherits' = 
    @{'V-Is' = 'dummy\conf.xml'}
  }
}
~~~
* собственное значение узла в XML или с использованем `V-Is`
~~~ xml
<OV-MyConf>
  <SV-Inherits>dummy\conf.xml</SV-Inherits>
</OV-MyConf>
~~~
~~~ xml
<OV-MyConf>
  <SV-Inherits V-Is="dummy\conf.xml" />
</OV-MyConf>
~~~
* собственное значение узла в JSON или с использованем `V-Is`
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": { "V-Is": "dummy\\conf.xml" }}
}
~~~
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": "dummy\\conf.xml" }
}
~~~

Простое значение может иметь подъузлы (потомков), но наличие "собственного значения" обязательно.

Пример, значение: `$SVInherits = 'dummy\conf.xml' | Add-Member -Name SVRequired -Value YES -MemberType NoteProperty -PassThru`, может быть сохранено как:
* Powershell Data с использованем `V-Is`
~~~ powershell
@{'OV-MyConf' = 
  @{'SV-Inherits' = 
    @{'V-Is'        = 'dummy\conf.xml'
    ; 'SV-Required' = 'YES'
    }
  }
}
~~~
* собственное значение узла в XML или с использованем `V-Is`
~~~ xml
<OV-MyConf>
  <SV-Inherits V-Is="dummy\conf.xml" SV-Required="YES"/>
</OV-MyConf>
~~~
~~~ xml
<OV-MyConf>
  <SV-Inherits SV-Required="YES" >dummy\conf.xml</SV-Inherits>
<OV-MyConf>
~~~
* JSON или с использованем `V-Is`
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": { "V-Is": "dummy\\conf.xml", "SV-Required": "YES"}}
}
~~~

Список значений может быть представлен в формате простого значения, тогда он трактуется как список из одного элемента.

Пример, список значений: `$LVServer = @('FOO', 'BAR')`, может быть сохранен как:
* Powershell data массив
~~~ powershell
@{'OV-MyConf' = 
  @{'LV-Server' = @('FOO', 'BAR') }
}
~~~
* XML узлы с одинаковыми именами трактуются как массив
~~~ xml
<OV-MyConf>
  <LV-Server V-Is="FOO" />
  <LV-Server V-Is="BAR" />  
</OV-MyConf>
~~~
* JSON массив
~~~ json
{  "OV-MyConf": 
  {  "LV-Server": ["FOO", "BAR"]}
}
~~~

Пример, список значений из одного элемента: `$LVServer = @('ONLY')`, может быть сохранен как:
* Powershell data массив или одиночное значение
~~~ powershell
@{'OV-MyConf' = 
  @{'LV-Server' = @('ONLY') }
}
~~~
~~~ powershell
@{'OV-MyConf' = 
  @{'LV-Server' = 'ONLY'}
}
~~~
* XML одиночное значение
~~~ xml
<OV-MyConf>
  <LV-Server V-Is="ONLY" />
</OV-MyConf>
~~~
* JSON массив или одиночное значение
~~~ json
{  "OV-MyConf": 
  {  "LV-Server": "ONLY"}
}
~~~
~~~ json
{  "OV-MyConf": 
  {  "LV-Server": ["ONLY"]}
}
~~~

Языковой формат файла не важен, главное связь потомок-родитель - т.е. путь к узлу.

Пример, набор значений: `$SVInherits = 'dummy\conf.xml' | Add-Member -Name SVRequired -Value YES -MemberType NoteProperty -PassThru`, может быть сохранен как:
* Powershell data
~~~ powershell
@{'OV-MyConf' = 
  @{'SV-Inherits' = 
    @{'V-Is'        = 'dummy\conf.xml'
    ; 'SV-Required' = 'YES'
    }
  }
}
~~~
* XML в виде атрибутов и простых элементов
~~~ xml
<OV-MyConf>
  <SV-Inherits V-Is="dummy\conf.xml" SV-Required="YES"/>
</OV-MyConf>
~~~
~~~ xml
<OV-MyConf>
  <SV-Inherits>
    <V-Is>dummy\conf.xml</V-Is>
    <SV-Required>YES</SV-Required>
  </SV-Inherits>
<OV-MyConf>
~~~
* JSON
~~~ json
{  "OV-MyConf": 
  {  "SV-Inherits": { "V-Is": "dummy\\conf.xml", "SV-Required": "YES"}}
}
~~~
